# 如何避免缓存穿透问题

场景:查询一个一定不存在的数据,由于缓存是不命中时被动写(从DB查询到数据,更新到缓存),并且处于容错考虑,
如果从DB查不到数据则不写入缓存,这将导致这个不存的数据每次请求都到DB去查询.

流量大时,DB就挂掉,要是有人利用不存在的key频繁攻击应用,这就漏洞

![image](https://github.com/williamzhang11/fastThinking/blob/master/src/main/java/com/xiu/fastThinking/image/cachejichuan.JPG)


方案:

方案1:缓存空对象

当从DB查询数据为空,仍将这个空结果进行缓存,具体的值使用特殊标识,能和真正缓存数据区分开
另外需要设置较短过期时间,一般不超过5分钟.如果此时存储层添加了这个数据，那此段时间就会出现
缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。

方案2:BloomFilter布隆过滤器

在缓存服务基础上,构建BloomFilter数据结构,在BloomFilter中存储对应key是否存在,如果存在,说明
说明该 KEY 对应的值为空。那么整个逻辑的如下

1.根据 KEY 查询缓存。如果存在对应的值，直接返回；如果不存在，继续向下执行

2.根据 KEY 查询在缓存 BloomFilter 的值。如果存在值，说明该 KEY 不存在对应的值，直接返回空；
如果不存在值，继续向下执行。

3.查询 DB 对应的值，如果存在，则更新到缓存，并返回该值。如果不存在值，
更新到 缓存 BloomFilter 中，并返回空

比较

缓存空对象:

适用场景:1.数据命中不高 2.保证一致性

维护成本:1.代码维护简单2.需要过多的缓存空间3.数据不一致

布隆过滤器:

适用场景:1.数据命中不高 2.数据相对固定,实时性低

维护成本:

1.代码维护复杂
2.缓存空间占用小
3.需要另外维护一个集合来存放缓存的Key
4.布隆过滤器不支持删值操作


BloomFilter更加节省内容，对缓存的负荷更小。并且，常用的缓存 Redis 支持构建 BloomFilter 数据结构









