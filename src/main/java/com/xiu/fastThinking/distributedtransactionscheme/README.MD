# 分布式事务方案

分布式事务的实现主要有以下 6 种方案：

XA 方案

TCC 方案

本地消息表

可靠消息最终一致性方案

最大努力通知方案

SAGA

## XA 方案

它定义的 TM（Transaction Manager）与 RM（Resource Manager）之间进行通信的接口。

Java中 的 javax.transaction.xa.XAResource 定义了 XA 接口，它依赖数据库厂商对 jdbc-driver 
的具体实现

在 XA 规范中，数据库充当 RM 角色，应用需要充当 TM 的角色，即生成全局的 txId ，调用 XAResource 接口，
把多个本地事务协调为全局统一的分布式事务

目前 XA 有两种实现：

基于一阶段提交( 1PC ) 的弱 XA 。
基于二阶段提交( 2PC ) 的强 XA 。


### 弱 XA
弱 XA 通过去掉 XA 的 Prepare 阶段，以达到减少资源锁定范围而提升并发性能的效果。典型的实现为在一个
业务线程中，遍历所有的数据库连接，依次做 commit 或者 rollback 。
弱 XA 同本地事务相比，性能损耗低，但在事务提交的执行过程中，若出现网络故障、数据库宕机等预期之外的异
常，将会造成数据不一致，且无法进行回滚。

基于弱 XA 的事务无需额外的实现成本，相对容易

MyCAT ，具体的源码解析，可以看看 《MyCAT 源码分析 —— XA 分布式事务》 。

Sharding-Sphere 默认支持。


### 强 XA

二阶段提交是 XA 的标准实现。它将分布式事务的提交拆分为 2 个阶段：prepare 和 commit/rollback 。

![image](https://github.com/williamzhang11/fastThinking/blob/master/src/main/java/com/xiu/fastThinking/image/distributetrans.JPG)


第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交

第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。

启 XA 全局事务后，所有子事务会按照本地默认的隔离级别锁定资源，并记录 undo 和 redo 日志。
然后由 TM 发起 prepare 投票，询问所有的子事务是否可以进行提交：

当所有子事务反馈的结果为 “yes” 时，TM 再发起 commit 。

若其中任何一个子事务反馈的结果为“no”，TM 则发起 rollback 。

如果在 prepare 阶段的反馈结果为 “yes” ，而 commit 的过程中出现宕机等异常时，则在节点服务重启后，可根据 XA 
recover 再次进行 commit 补偿，以保证数据的一致性。

优点:

尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现


缺点:

1.单点问题：事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段
正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。

2.同步阻塞：在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源

3.数据不一致：两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如
在第二阶段中，假设协调者发出了事务commit 的通知，但是因为网络问题该通知仅被一部分参与者所收到
并执行了 commit 操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不
一致性。

方案:

Sharding Sphere

Sharding Sphere

场景:

这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。

这个方案，我们很少用.

现在微服务，一个大的系统分成几百个服务，几十个服务。一般来说，我们的规定和规范，是要求每个服务只能操作自己对应的一个数据库。

如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。

如果你要操作别人的服务的库，你必须是通过调用别的服务的接口来实现，绝对不允许交叉访问别人的数据库

![image](https://github.com/williamzhang11/fastThinking/blob/master/src/main/java/com/xiu/fastThinking/image/sa.JPG)

## TCC方案

TCC 模型是把锁的粒度完全交给业务处理，它需要每个子事务业务都实现Try-Confirm / Cancel 接口

Try:

	尝试执行业务
	完成所有业务检查（一致性）
	预留必须业务资源（准隔离性）

Confirm:

	确认执行业务；
	真正执行业务，不作任何业务检查
	只使用Try阶段预留的业务资源
	Confirm 操作满足幂等性

Cancel:

	取消执行业务
	释放Try阶段预留的业务资源
	Cancel操作满足幂等性
	
这三个阶段，都会按本地事务的方式执行。不同于 XA的prepare ，TCC 无需将 XA 的投票期间的所有
资源挂起，因此极大的提高了吞吐量。


TCC 模型对业务的侵入强，改造的难度大.当然，如果能不用 TCC 的情况下，尽量不要用 TCC 。因为，
编写回滚逻辑的代码，可能会比较恶心


![image](https://github.com/williamzhang11/fastThinking/blob/master/src/main/java/com/xiu/fastThinking/image/tccandxa.JPG)

 1) 在阶段1：

    在XA中，各个RM准备提交各自的事务分支，事实上就是准备提交资源的更新操作(insert、delete、update等)；而在TCC中，是主业务活动请求(try)各个从业务服务预留资源。

 2) 在阶段2：

    XA根据第一阶段每个RM是否都prepare成功，判断是要提交还是回滚。如果都prepare成功，那么就commit每个事务分支，反之则rollback每个事务分支。

    TCC中，如果在第一阶段所有业务资源都预留成功，那么confirm各个从业务服务，否则取消(cancel)所有从业务服务的资源预留请求。


 XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁。

       XA事务中的两阶段提交内部过程是对开发者屏蔽的，回顾我们之前讲解JTA规范时，通过UserTransaction的commit方法来提交全局事务，这只是一次方法调用，其内部会委派给TransactionManager进行真正的两阶段提交，因此开发者从代码层面是感知不到这个过程的。而事务管理器在两阶段提交过程中，从prepare到commit/rollback过程中，资源实际上一直都是被加锁的。如果有其他人需要更新这两条记录，那么就必须等待锁释放。

   TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁。

     TCC中的两阶段提交并没有对开发者完全屏蔽，也就是说从代码层面，开发者是可以感受到两阶段提交的存在。如上述航班预定案例：在第一阶段，航空公司需要提供try接口(机票资源预留)。在第二阶段，航空公司提需要提供confirm/cancel接口(确认购买机票/取消预留)。开发者明显的感知到了两阶段提交过程的存在。try、confirm/cancel在执行过程中，一般都会开启各自的本地事务，来保证方法内部业务逻辑的ACID特性。其中：

    1、try过程的本地事务，是保证资源预留的业务逻辑的正确性。

    2、confirm/cancel执行的本地事务逻辑确认/取消预留资源，以保证最终一致性，也就是所谓的补偿型事务(Compensation-Based Transactions)。

由于是多个独立的本地事务，因此不会对资源一直加锁。






## 可靠消息最终一致性方案

直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。

1.A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；

2.如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；

3.如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；

4.mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。

5.这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。

![image](https://github.com/williamzhang11/fastThinking/blob/master/src/main/java/com/xiu/fastThinking/image/rocketmq.JPG)

## 如何处理分布式事务的？

某某特别严格的场景，用的是 TCC 来保证强一致性（严格资金要求）

其他的一些场景，基于阿里的 RocketMQ 来实现了分布式事务（一般的分布式事务场景，订单插入
之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案）

## 事务解决方案的对比总结

TCC 和 MQ 都是以服务为范围进行分布式事务的处理，而 XA、BED、SAGA 则是以数据库为范围进行分布式处理。





