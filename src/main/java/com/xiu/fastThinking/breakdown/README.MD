# 如何避免缓存击穿问题

场景:

某个极度热点数据在某个时间点过期,巧合在这时间点对这个key有大量并发请求过来,这些请求发现缓存过期一般都
会从DB加载数据并设到缓存,这个时候大并发请求可能可能会瞬间DB压垮

缓存被击穿和缓存雪崩的区别是,击穿问题针对某一个key缓存,雪崩针对很多key
和缓存穿透的区别在于,这个key是真实存在的值

方案:

方案1:使用分布式锁:请求发现缓存不存在后,去查询DB前,使用分布式锁,保证有且只有一个线程去查询DB,
	并更新到缓存.如下:
	
	1.获取分布式锁,直到成功或超时,如果超时则抛出异常,返回.如果成功,继续向下
	2.缓存中如果存在值,则直接返回;不存在则继续往下执行
	3.查询DB,更新到缓存,返回值.
	
方案2，手动过期：缓存上从不设置过期时间，功能上将过期时间存在 KEY 对应的 VALUE 里，
如果发现要过期，通过一个后台的异步线程进行缓存的构建，也就是“手动”过期。通过后台的异步线程，
保证有且只有一个线程去查询 DB。
	
使用分布式锁

优点:
1.思路简单

2.保证一致性

缺点:
1. 代码复杂度大

2.存在死锁风险

手动过期

优点:性能最佳,用户无序等待

缺点:无法保证缓存一致性


	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	