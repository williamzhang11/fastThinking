# 分片键如何选择

分库分表后，分片键的选择非常重要。一般来说是这样的：

信息表，使用 id 进行分片。例如说，文章、商品信息等等。
业务表，使用 user_id 进行分片。例如说，订单表、支付表等等。
日志表，使用 create_time 进行分片。例如说，访问日志、登陆日志等等

## 分片算法的选择？

选择好分片键之后，还需要考虑分片算法。一般来说，有如下两种：

取余分片算法。例如说，有四个库，那么 user_id 为 10 时，分到第 10 % 4 = 2 个库。
当然，如果分片键是字符串，则需要先进行 hash 的方式，转换成整形，这样才可以取余。
当然，如果分片键是整数，也可以使用 hash 的方式。


范围算法。
例如说，时间范围。
上述两种算法，各有优缺点。

对于取余来说：

好处，可以平均分配每个库的数据量和请求压力。

坏处，在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表。

对于 range 来说：
好处，扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了。

缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要看场景。


## 如果查询条件不带分片键，怎么办？

当查询不带分片键时，则中间件一般会扫描所有库表，然后聚合结果，然后进行返回。

对于大多数情况下，如果每个库表的查询速度还可以，返回结果的速度也是不错的


## 使用 user_id 分库分表后，使用 id 查询怎么办？

有四种方案。

（1）不处理

如果性能可以接受，可以不去处理。当然，前提是这样的查询不多，不会给系统带来负担。

（2）映射关系

创建映射表，只有 id、user_id 两列字段。使用 id 查询时，先从映射表获得 id 对应的 user_id ，然后再使用 id + user_id 去查询对应的表。

当然，随着业务量的增长，映射表也会越来越大，后续也可能需要进行分库分表。

对于这方式，也可以有一些优化方案。

映射表改成缓存到 Redis 等 KV 缓存中。当然，需要考虑如果 Redis 持久化的情况。
将映射表缓存到内存中，减少一次到映射表的查询。


3）基因 id

分库基因：假如通过 user_id 分库，分为 8 个库，采用 user_id % 8 的方式进行路由，此
时是由 user_id 的最后 3bit 来决定这行 User 数据具体落到哪个库上，那么这 3bit 可以看为分
库基因。那么，如果我们将这 3 bit 参考类似 Snowflake 的方式，融入进入到 id 。


## 如何解决分布式事务



目前市面上，分布式事务的解决方案还是蛮多的，但是都是基于一个前提，需要保证本地事务。那么，就对我
们在分库分表时，就有相应的要求：数据在分库分表时，需要保证一个逻辑中，能够形成本地事务。举个例
子，创建订单时，我们会插入订单表和订单明细表，那么：

如果我们基于这两个表的 id 进行分库分表，将会导致插入的记录被分到不同的库表中，因为创建下单可以购
买 n 个商品，那么就会有 1 条订单记录和 n 条 订单明细记录。而这 n 条订单明细记录无法和 1 条订单记
录分到一个库表中。
如果我们基于这两个表的 user_id 进行分库分表，那么插入的记录被分到相同的库表中。


为什么一定要形成本地事务？在有了本地事务的基础上，通过使用分布式事务的解决方案，协调多个本地
事务，形成最终一致性。另外，本地事务在这个过程中，能够保证万一执行失败，再重试时，不会产生脏数据。




